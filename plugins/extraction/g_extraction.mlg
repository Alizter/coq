(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *         Copyright INRIA, CNRS and contributors             *)
(* <O___,, * (see version control and CREDITS file for authors & dates) *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

{

open Pcoq.Prim

}

DECLARE PLUGIN "coq-core.plugins.extraction"

{

(* ML names *)

open Ltac_plugin
open Stdarg

let pr_mlname _ _ _ s = Pp.(spc () ++ qs s)

}

ARGUMENT EXTEND mlname
  TYPED AS string
  PRINTED BY { pr_mlname }
| [ preident(id) ] -> { id }
| [ string(s) ] -> { s }
END

{

let pr_int_or_id _ _ _ = function
  | Table.ArgInt i -> Pp.int i
  | Table.ArgId id -> Names.Id.print id

}

ARGUMENT EXTEND int_or_id
  PRINTED BY { pr_int_or_id }
| [ preident(id) ] -> { Table.ArgId (Names.Id.of_string id) }
| [ integer(i) ] -> { Table.ArgInt i }
END

{

let pr_language = function
  | Table.Ocaml -> Pp.str "OCaml"
  | Table.Haskell -> Pp.str "Haskell"
  | Table.Scheme -> Pp.str "Scheme"
  | Table.JSON -> Pp.str "JSON"

}

VERNAC ARGUMENT EXTEND language
PRINTED BY { pr_language }
| [ "OCaml" ] -> { Table.Ocaml }
| [ "Haskell" ] -> { Table.Haskell }
| [ "Scheme" ] -> { Table.Scheme }
| [ "JSON" ] -> { Table.JSON }
END

(* Extraction commands *)

VERNAC COMMAND EXTEND Extraction CLASSIFIED AS QUERY
(* Extraction in the Coq toplevel *)
| [ "Extraction" global(x) ] -> { Extract_env.simple_extraction x }
| [ "Recursive" "Extraction" ne_global_list(l) ] -> { Extract_env.full_extraction None l }

(* Monolithic extraction to a file *)
| [ "Extraction" string(f) ne_global_list(l) ]
  -> { Extract_env.full_extraction (Some f) l }

(* Extraction to a temporary file and OCaml compilation *)
| [ "Extraction" "TestCompile" ne_global_list(l) ]
  -> { Extract_env.extract_and_compile l }
END

VERNAC COMMAND EXTEND SeparateExtraction CLASSIFIED AS QUERY
(* Same, with content split in several files *)
| [ "Separate" "Extraction" ne_global_list(l) ]
  -> { Extract_env.separate_extraction l }
END

(* Modular extraction (one Coq library = one ML module) *)
VERNAC COMMAND EXTEND ExtractionLibrary CLASSIFIED AS QUERY
| [ "Extraction" "Library" identref(m) ]
  -> { Extract_env.extraction_library false m }
END

VERNAC COMMAND EXTEND RecursiveExtractionLibrary CLASSIFIED AS QUERY
| [ "Recursive" "Extraction" "Library" identref(m) ]
  -> { Extract_env.extraction_library true m }
END

(* Target Language *)
VERNAC COMMAND EXTEND ExtractionLanguage CLASSIFIED AS SIDEFF
| [ "Extraction" "Language" language(l) ]
  -> { Table.extraction_language l }
END

VERNAC COMMAND EXTEND ExtractionInline CLASSIFIED AS SIDEFF
(* Custom inlining directives *)
| [ "Extraction" "Inline" ne_global_list(l) ]
  -> { Table.extraction_inline true l }
END

VERNAC COMMAND EXTEND ExtractionNoInline CLASSIFIED AS SIDEFF
| [ "Extraction" "NoInline" ne_global_list(l) ]
  -> { Table.extraction_inline false l }
END

VERNAC COMMAND EXTEND PrintExtractionInline CLASSIFIED AS QUERY
| [ "Print" "Extraction" "Inline" ]
  -> {Feedback.msg_notice (Table.print_extraction_inline ()) }
END

VERNAC COMMAND EXTEND ResetExtractionInline CLASSIFIED AS SIDEFF
| [ "Reset" "Extraction" "Inline" ]
  -> { Table.reset_extraction_inline () }
END

VERNAC COMMAND EXTEND ExtractionImplicit CLASSIFIED AS SIDEFF
(* Custom implicit arguments of some csts/inds/constructors *)
| [ "Extraction" "Implicit" global(r) "[" int_or_id_list(l) "]" ]
  -> { Table.extraction_implicit r l }
END

VERNAC COMMAND EXTEND ExtractionBlacklist CLASSIFIED AS SIDEFF
(* Force Extraction to not use some filenames *)
| [ "Extraction" "Blacklist" ne_preident_list(l) ]
  -> { Table.extraction_blacklist l }
END

VERNAC COMMAND EXTEND PrintExtractionBlacklist CLASSIFIED AS QUERY
| [ "Print" "Extraction" "Blacklist" ]
  -> { Feedback.msg_notice (Table.print_extraction_blacklist ()) }
END

VERNAC COMMAND EXTEND ResetExtractionBlacklist CLASSIFIED AS SIDEFF
| [ "Reset" "Extraction" "Blacklist" ]
  -> { Table.reset_extraction_blacklist () }
END


(* Overriding of a Coq object by an ML one *)
VERNAC COMMAND EXTEND ExtractionConstant CLASSIFIED AS SIDEFF
| [ "Extract" "Constant" global(x) string_list(idl) "=>" mlname(y) ]
  -> { Table.extract_constant_inline false x idl y }
END

VERNAC COMMAND EXTEND ExtractionInlinedConstant CLASSIFIED AS SIDEFF
| [ "Extract" "Inlined" "Constant" global(x) "=>" mlname(y) ]
  -> { Table.extract_constant_inline true x [] y }
END

VERNAC COMMAND EXTEND ExtractionInductive CLASSIFIED AS SIDEFF
| [ "Extract" "Inductive" global(x) "=>"
    mlname(id) "[" mlname_list(idl) "]" string_opt(o) ]
  -> { Table.extract_inductive x id idl o }
END
(* Show the extraction of the current proof *)

VERNAC COMMAND EXTEND ShowExtraction CLASSIFIED AS QUERY STATE proof_query
| [ "Show" "Extraction" ]
  -> { Extract_env.show_extraction }
END
